### 一、 先给核心结论：面向抽象编程是什么？

面向抽象编程（也叫「面向接口编程」，抽象载体包括「接口」和「抽象类」），核心一句话就能概括：

**「只和「规则 / 约定」打交道，不关心「具体是谁在执行、怎么执行」」**。

对应到 Java 中：

- 「抽象」= 接口（`interface`）/ 抽象类（`abstract class`）：只定义「能做什么」（统一方法），不实现「怎么做」（无具体逻辑，或只留空架子）。
- 「具体实现」= 普通子类：继承 / 实现抽象，完成「怎么做」的具体逻辑。
- 「编程」= 写代码时，只调用抽象暴露的方法，从不直接操作具体子类。

大白话类比：

你想喝水，只需要「拿起杯子→往嘴里倒」（这是「抽象规则」，杯子的统一功能），不用关心杯子是「玻璃杯、陶瓷杯、塑料杯」（这是「具体实现」），也不用关心杯子是怎么「被生产出来的」（实现细节）。只要是杯子，就能完成「装水、喝水」的功能，这就是面向抽象编程。

### 二、 先看「反例」：不面向抽象编程（依赖具体实现）

先看一段「不好」的代码，理解其中的问题，再对比面向抽象的优势，你会更有感觉。

#### 需求：实现「狗叫」和「猫叫」的功能

java

运行

```
// 1. 具体实现类1：狗
class Dog {
    // 狗的叫方法（具体实现）
    public void dogBark() {
        System.out.println("狗：汪汪汪");
    }
}

// 2. 具体实现类2：猫
class Cat {
    // 猫的叫方法（具体实现）
    public void catMeow() {
        System.out.println("猫：喵喵喵");
    }
}

// 3. 主类（直接依赖具体子类）
public class BadDemo {
    public static void main(String[] args) {
        // 直接创建具体子类对象，调用子类特有方法
        Dog dog = new Dog();
        Cat cat = new Cat();
        
        // 调用的是子类特有方法，方法名不一样
        dog.dogBark();
        cat.catMeow();
    }
}
```

#### 这段代码的问题（为什么不推荐）

1. **强依赖具体子类，耦合度高**：主类直接和`Dog`、`Cat`打交道，一旦需求变更（比如新增「鸡叫」、修改狗叫的逻辑），必须修改主类的代码。

- 比如新增「鸡」，需要新增`Chicken`类，还要在主类中添加`Chicken chicken = new Chicken(); chicken.chickenCluck();`。

2. **方法不统一，调用繁琐**：狗叫是`dogBark()`，猫叫是`catMeow()`，调用者需要记住不同的方法名，代码冗余且不易维护。
3. **扩展性差**：新增动物时，必须修改主类，违反「开闭原则」（对扩展开放，对修改关闭）。

### 三、 再看「正例」：面向抽象编程（依赖抽象，不依赖具体）

还是同一个需求，用面向抽象编程实现，对比上面的反例，看差异在哪里。

java

运行

```
// 1. 定义抽象（接口）：动物叫的统一规则（只定义「能叫」，不实现「怎么叫」）
interface Animal {
    void bark(); // 统一方法：叫（所有动物都要遵守这个规则）
}

// 2. 具体实现类1：狗（实现抽象规则，完成具体逻辑）
class Dog implements Animal {
    // 重写：狗的具体叫逻辑
    @Override
    public void bark() {
        System.out.println("狗：汪汪汪");
    }
}

// 3. 具体实现类2：猫（实现抽象规则，完成具体逻辑）
class Cat implements Animal {
    // 重写：猫的具体叫逻辑
    @Override
    public void bark() {
        System.out.println("猫：喵喵喵");
    }
}

// 4. 主类（只和抽象打交道，不依赖具体子类）
public class GoodDemo {
    public static void main(String[] args) {
        // 核心：抽象（Animal）引用 指向 子类（Dog/Cat）对象
        // 只认识Animal这个抽象，不关心具体是Dog还是Cat
        Animal dog = new Dog();
        Animal cat = new Cat();
        
        // 核心：调用抽象定义的统一方法，不用关心具体实现
        dog.bark();
        cat.bark();
    }
}
```

#### 运行结果（和反例一致，但代码更优）

plaintext

```
狗：汪汪汪
猫：喵喵喵
```

#### 这段代码的优势（面向抽象的核心价值）

1. **弱依赖，解耦**：主类只和`Animal`这个抽象打交道，不知道也不关心具体是「狗」还是「猫」，只需要调用统一的`bark()`方法即可。

- 即使修改狗叫的逻辑（比如改成「狗：旺～旺～旺～」），也只需要修改`Dog`类，主类完全不用动。

2. **方法统一，简化调用**：所有子类都实现了统一的`bark()`方法，调用者不用记住不同的方法名，代码更简洁、可读性更高。
3. **扩展性极强（核心魅力）**：如果新增「鸡叫」，只需要做**2 件事，无需修改任何现有代码**：

- 新增`Chicken`类，实现`Animal`接口，重写`bark()`方法；
- 主类中新增一行`Animal chicken = new Chicken(); chicken.bark();`。
    
    这就是「开闭原则」，新增功能只需要扩展，不需要修改原有代码，这也是面向抽象编程的核心价值。

### 四、 面向抽象编程的「核心载体」：接口 vs 抽象类

Java 中，「抽象」有两个核心载体，新手不用纠结细节，先理解它们的「共性」，再记住「简单差异」即可。

#### 1. 共性（核心）

- 都**不能实例化**（不能用`new`创建对象，比如`new Animal()`、`new abstract class()`都是错误的）；
- 都用于**定义统一规则**，约束子类的行为；
- 都能实现「父类 / 接口引用指向子类对象」，支撑多态和面向抽象编程。

#### 2. 简单差异（新手必记，够用即可）

|对比维度|接口（`interface`）|抽象类（`abstract class`）|
|---|---|---|
|关键字|`interface`，子类用`implements`实现|`abstract class`，子类用`extends`继承|
|方法|默认「无实现」（JDK8 + 支持默认方法 / 静态方法）|可以有「有实现的普通方法」+「无实现的抽象方法」（`abstract`修饰）|
|成员变量|只能是「常量」（`public static final`）|可以有「普通成员变量」（如`int age;`）|
|继承 / 实现数量|一个类可以实现「多个接口」（弥补 Java 单继承）|一个类只能「继承一个抽象类」（Java 单继承）|
|适用场景|只定义「行为规则」，不关心属性和默认实现|既有「统一行为规则」，又有「公共属性 / 默认实现」|

#### 3. 新手建议

- 如果你只需要定义「统一的行为」（比如「动物会叫」、「收入要计税」），优先用**接口**，更灵活（支持多实现）；
- 如果你需要「公共属性 + 统一行为」（比如「动物有年龄 + 会叫」），用**抽象类**，可以减少子类的重复代码（比如抽象类中定义`int age;`，子类直接使用）。

### 五、 面向抽象编程的「核心步骤」（三步走，新手直接套用）

1. **定义抽象**：提取所有具体实现的「公共行为」，封装到接口 / 抽象类中，定义统一方法（无具体实现，或只留默认实现）。

- 示例：提取「动物会叫」，封装到`Animal`接口，定义`bark()`方法。

2. **实现具体**：创建具体子类，继承 / 实现抽象，重写抽象方法，完成具体业务逻辑。

- 示例：`Dog`、`Cat`实现`Animal`接口，重写`bark()`方法，实现各自的叫逻辑。

3. **编程抽象**：写业务代码时，只声明「抽象类型」的变量，调用抽象定义的方法，不直接操作具体子类。

- 示例：`Animal dog = new Dog(); dog.bark();`，只和`Animal`打交道，不关心具体是`Dog`还是`Cat`。

### 六、 总结（核心要点回顾）

1. 面向抽象编程的核心是「**依赖抽象，不依赖具体实现**」，核心价值是「解耦、高扩展性、简化调用」。
2. 抽象（接口 / 抽象类）的作用是「定义统一规则，隐藏实现细节」，具体子类的作用是「实现规则，完成具体逻辑」。
3. 面向抽象编程的关键是「**父类 / 接口引用指向子类对象**」，调用抽象的统一方法，无需关心子类的具体实现。
4. 新手入门的核心：不用纠结接口和抽象类的细节，先从「简化扩展、减少修改」的角度理解，在实战中逐步加深体会，先会用，再精通。