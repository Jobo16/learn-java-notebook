---
title: 专题-包装类型内存占用
category: 04-泛型与装箱
topic: 30-专题-自动拆装箱
created: 2026-01-26
reviewed: 2026-02-02
tags: [java, 泛型与装箱]
status: active
---


### 一、 包装类型的核心定义

Java 中的包装类型（Wrapper Class）是**8 种基本数据类型对应的引用类型**，目的是解决基本类型无法参与 “面向对象” 相关操作（如存入集合、作为泛型参数、调用`Object`类方法）的问题，同时提供了大量数据处理的工具方法。

| 基本类型    | 对应的包装类型   | 继承关系                      | 占用堆内存（32 位 JVM，近似） |
| ------- | --------- | ------------------------- | ------------------ |
| byte    | Byte      | Object → Number → Byte    | 16 字节              |
| short   | Short     | Object → Number → Short   | 16 字节              |
| int     | Integer   | Object → Number → Integer | 16 字节              |
| long    | Long      | Object → Number → Long    | 24 字节              |
| float   | Float     | Object → Number → Float   | 16 字节              |
| double  | Double    | Object → Number → Double  | 24 字节              |
| char    | Character | Object → Character        | 16 字节              |
| boolean | Boolean   | Object → Boolean          | 16 字节              |

> 说明：`Number`是一个抽象类，封装了数值型包装类型（`Byte/Short/Integer/Long/Float/Double`）的通用方法（如`intValue()`、`longValue()`）；`Character`和`Boolean`直接继承自`Object`。

### 二、 包装类型的核心特性

#### 1. 不可变性（Immutable）

所有包装类型都是**不可变类**，一旦创建对象，其内部存储的基本类型值就无法修改。

- 实现原理：包装类型内部的基本类型成员变量被`final`修饰，且没有提供修改该值的`setter`方法。
- 示例（`Integer`）：
    
    java
    
    运行
    
    ```
    public class Integer {
        private final int value; // 核心成员变量被final修饰，不可修改
        
        public Integer(int value) {
            this.value = value;
        }
    }
    ```
    
- 注意：看似 “修改” 包装类型变量的操作，实际是创建了一个新的包装对象，原对象的值不变。
    
    java
    
    运行
    
    ```
    Integer a = 10;
    a = 20; // 不是修改原Integer对象的值，而是创建了一个值为20的新Integer对象，a指向新对象
    ```
    

#### 2. 自动拆装箱（Autoboxing/Unboxing）

这是 Java 5 引入的**语法糖**，编译器自动完成包装类型和基本类型之间的转换，无需手动调用转换方法，核心细节如下：

- 自动装箱：基本类型 → 包装类型，编译器自动调用`valueOf()`方法（推荐，比直接`new Integer()`更高效，有缓存优化）。
    
    java
    
    运行
    
    ```
    Integer a = 10; // 等价于 Integer a = Integer.valueOf(10);
    ```
    
- 自动拆箱：包装类型 → 基本类型，编译器自动调用对应的`xxxValue()`方法（如`intValue()`、`longValue()`）。
    
    java
    
    运行
    
    ```
    int b = a; // 等价于 int b = a.intValue();
    ```
    
- 常见使用场景：集合存储数据、泛型参数、方法参数 / 返回值类型匹配、运算操作（包装类型参与算术运算时，会先拆箱为基本类型）。

#### 3. 常量池缓存（Cache）

为了提升性能、减少内存开销，部分包装类型提供了**常量池缓存机制**，缓存一定范围内的对象，重复使用该范围内的对象，避免频繁创建新对象。

- 支持缓存的包装类型：`Byte、Short、Integer、Long、Character、Boolean`（`Float、Double`不支持，因为浮点型数据范围广，缓存性价比低）。
- 各类型缓存范围：
    
    1. `Byte`：缓存所有值（`[-128, 127]`，因为`byte`的取值范围本身就是这个区间）；
    2. `Short、Integer、Long`：默认缓存`[-128, 127]`，`Integer`可以通过 JVM 参数`-XX:AutoBoxCacheMax=<N>`扩大上限（不能缩小下限 128）；
    3. `Character`：缓存`[0, 127]`（对应 ASCII 码表中的字符）；
    4. `Boolean`：缓存`Boolean.TRUE`和`Boolean.FALSE`两个静态对象，无范围限制。
    
- 示例验证（`Integer`缓存）：
    

    ```
    // 缓存范围内：引用指向同一个对象，== 判断为true
    Integer a = 100;
    Integer b = 100;
    System.out.println(a == b); // 输出：true
    
    // 超出缓存范围：创建新对象，== 判断为false（== 比较引用地址）
    Integer c = 200;
    Integer d = 200;
    System.out.println(c == d); // 输出：false
    
    // 无论是否在缓存范围，equals() 比较的是对象的值，结果都为true
    System.out.println(c.equals(d)); // 输出：true
    ```
    
- 关键提醒：包装类型比较**是否相等**时，优先使用`equals()`方法，而非`==`（`==`比较的是对象引用地址，仅缓存范围内的对象才会返回 true，存在坑）。

### 三、 包装类型的常用核心方法

包装类型提供了大量静态方法和实例方法，用于数据类型转换、数据解析、常量获取等，以下是最常用的方法（以`Integer`为例，其他数值型包装类型用法类似）：

#### 1. 静态方法（最常用）

1. `Integer.valueOf(int i)`：将基本类型`int`转换为`Integer`对象，**推荐使用**（有缓存优化）；
2. `Integer.valueOf(String s)`：将符合格式的字符串`s`转换为`Integer`对象，抛出`NumberFormatException`（字符串无法解析为整数时）；
3. `Integer.parseInt(String s)`：将符合格式的字符串`s`转换为基本类型`int`，常用作字符串转整数；
4. `Integer.toString(int i)`：将基本类型`int`转换为字符串；
5. `Integer.toBinaryString(int i)`：将整数转换为二进制字符串；
6. `Integer.toHexString(int i)`：将整数转换为十六进制字符串；
7. 常量获取：`Integer.MAX_VALUE`（int 最大值：2^31-1）、`Integer.MIN_VALUE`（int 最小值：-2^31）。

#### 2. 实例方法

1. `int intValue()`：将`Integer`对象拆箱为基本类型`int`（自动拆箱的底层调用方法）；
2. `long longValue()`：将`Integer`对象转换为基本类型`long`；
3. `String toString()`：将`Integer`对象转换为字符串；
4. `boolean equals(Object obj)`：比较两个`Integer`对象的值是否相等（重写了`Object`的`equals()`方法，不再比较引用地址）。

#### 3. 示例代码

java

运行

```
public class WrapperDemo {
    public static void main(String[] args) {
        // 1. 字符串转整数
        String numStr = "123";
        int num1 = Integer.parseInt(numStr);
        Integer num2 = Integer.valueOf(numStr);
        System.out.println(num1); // 输出：123
        
        // 2. 整数转字符串/二进制/十六进制
        int num3 = 255;
        System.out.println(Integer.toString(num3)); // 输出：255
        System.out.println(Integer.toBinaryString(num3)); // 输出：11111111
        System.out.println(Integer.toHexString(num3)); // 输出：ff
        
        // 3. 获取int的最大值和最小值
        System.out.println(Integer.MAX_VALUE); // 输出：2147483647
        System.out.println(Integer.MIN_VALUE); // 输出：-2147483648
    }
}
```

### 四、 包装类型的使用注意事项

1. **避免使用`new`创建包装对象（优先用`valueOf()`）**：
    
    `new Integer(10)`会强制创建一个新的对象，不使用缓存，而`Integer.valueOf(10)`会复用缓存中的对象，更高效、更节省内存。
    
    java
    
    运行
    
    ```
    Integer a = new Integer(100);
    Integer b = new Integer(100);
    System.out.println(a == b); // 输出：false（两个不同的对象）
    
    Integer c = Integer.valueOf(100);
    Integer d = Integer.valueOf(100);
    System.out.println(c == d); // 输出：true（复用缓存对象）
    ```
    
2. **包装类型可以为`null`，避免空指针异常（NullPointerException）**：
    
    包装类型是引用类型，允许赋值为`null`，而基本类型不能为`null`。使用包装类型时，若未判空就进行拆箱操作，会抛出空指针异常。
    
    java
    
    运行
    
    ```
    Integer a = null;
    int b = a; // 编译通过，运行时抛出 NullPointerException（拆箱时调用a.intValue()，a为null）
    ```
    
    解决方案：使用包装类型前，先进行`null`判断（`if (a != null)`）。
    
3. **集合中存储的是包装类型，而非基本类型**：
    
    Java 集合（`List、Map、Set`等）仅支持存储引用类型，存入基本类型时会自动装箱为包装类型，取出时若需基本类型，会自动拆箱。
    
    java
    
    运行
    
    ```
    List<Integer> list = new ArrayList<>();
    list.add(10); // 自动装箱：10 → Integer.valueOf(10)
    int num = list.get(0); // 自动拆箱：Integer → intValue()
    ```
    
4. **浮点型包装类型的`equals()`比较存在精度问题**：
    
    `Float`和`Double`的`equals()`方法会严格比较数值精度，避免用`equals()`比较浮点型数据，如需比较，可指定精度范围。
    
    java
    
    运行
    
    ```
    Double a = 0.1 + 0.2;
    Double b = 0.3;
    System.out.println(a.equals(b)); // 输出：false（0.1+0.2=0.30000000000000004，与0.3不相等）
    ```
    

### 总结

1. 包装类型是基本类型的引用类型实现，解决了基本类型无法参与面向对象操作的问题，同时提供了丰富的工具方法。
2. 包装类型具有不可变性、自动拆装箱、部分类型支持常量池缓存三大核心特性，其中缓存能优化性能，`equals()`是比较值的正确方式。
3. 使用包装类型时，需避免`new`创建对象、防范`null`导致的空指针异常，浮点型包装类型的比较要注意精度问题。

