### 一、 先明确简化后的需求和计税规则

1. 需求：计算「工资收入」和「稿费收入」的税款，体现多态。
2. 简化计税规则（超简单，不用记复杂公式）：
    
    - 工资收入：直接按 **5%** 计税（比如工资 10000 元，税款就是 500 元）。
    - 稿费收入：直接按 **3%** 计税（比如稿费 5000 元，税款就是 150 元）。
    

### 二、 简化版完整可运行代码

这段代码只有 4 个部分，没有复杂的集合和管理类，聚焦多态核心：

java

运行

```
// 第一步：定义父类（收入）- 多态的基础，定义统一方法
class Income {
    // 收入金额
    double amount;

    // 构造方法：给收入金额赋值
    public Income(double amount) {
        this.amount = amount;
    }

    // 计算税款的方法（父类统一方法，后续被子类重写）
    public double calculateTax() {
        // 父类默认实现（可以留空，也可以写一个默认值）
        return 0.0;
    }
}

// 第二步：子类1 - 工资收入（重写计税方法）
class SalaryIncome extends Income {
    // 构造方法：调用父类构造方法，给收入金额赋值
    public SalaryIncome(double amount) {
        super(amount);
    }

    // 重写：工资的计税逻辑（5%税率）
    @Override
    public double calculateTax() {
        // 工资税款 = 工资金额 × 5%
        return this.amount * 0.05;
    }
}

// 第三步：子类2 - 稿费收入（重写计税方法）
class RoyaltyIncome extends Income {
    // 构造方法：调用父类构造方法，给收入金额赋值
    public RoyaltyIncome(double amount) {
        super(amount);
    }

    // 重写：稿费的计税逻辑（3%税率）
    @Override
    public double calculateTax() {
        // 稿费税款 = 稿费金额 × 3%
        return this.amount * 0.03;
    }
}

// 第四步：主类（测试程序，核心演示多态）
public class SimpleTaxDemo {
    public static void main(String[] args) {
        // 1. 父类引用 指向 工资收入子类对象（多态核心：父类装子类）
        Income salary = new SalaryIncome(10000.0); // 工资10000元
        // 2. 父类引用 指向 稿费收入子类对象
        Income royalty = new RoyaltyIncome(5000.0); // 稿费5000元

        // 3. 统一调用 calculateTax() 方法，体现多态
        System.out.println("工资10000元应缴税款：" + salary.calculateTax() + " 元");
        System.out.println("稿费5000元应缴税款：" + royalty.calculateTax() + " 元");
        System.out.println("总税款：" + (salary.calculateTax() + royalty.calculateTax()) + " 元");
    }
}
```

### 三、 运行结果（一目了然）

plaintext

```
工资10000元应缴税款：500.0 元
稿费5000元应缴税款：150.0 元
总税款：650.0 元
```

### 四、 逐部分拆解（大白话，保证看懂）

#### 1. 父类 `Income`：定义「收入」的统一模板

- 这个类就像一个「通用收入说明书」，规定了所有收入都有「金额」，都要「计算税款」。
- `double amount`：存储收入的具体金额（比如 10000 元、5000 元）。
- `calculateTax()`：统一的计税方法，父类里写了个默认返回 0.0，后续让子类自己改（重写）这个方法的逻辑。

#### 2. 子类 `SalaryIncome`（工资收入）：实现工资的计税逻辑

- `extends Income`：表示工资收入是「收入」的一种，继承父类的所有属性和方法。
- `super(amount)`：调用父类的构造方法，把工资金额传给父类的`amount`，相当于给父类的「金额」赋值。
- `@Override + calculateTax()`：重写父类的计税方法，写工资自己的规则（×5%），这是多态的关键（子类有自己的实现）。

#### 3. 子类 `RoyaltyIncome`（稿费收入）：实现稿费的计税逻辑

- 和工资子类逻辑完全一样，只是重写的计税方法里，规则变成了 ×3%，这就是「同一个方法，不同子类有不同实现」。

#### 4. 主类：演示多态的核心（最关键）

- `Income salary = new SalaryIncome(10000.0);`：这句话是多态的核心，拆成两句理解：
    
    1. 左边 `Income salary`：声明一个「通用收入」类型的变量，名字叫`salary`。
    2. 右边 `new SalaryIncome(10000.0)`：实际创建的是「工资收入」对象，金额 10000 元。
    3. 简单说：用一个「通用袋子」（父类），装了一个「工资包子」（子类），这就是「父类引用指向子类对象」。
    
- `Income royalty = new RoyaltyIncome(5000.0);`：同理，用「通用袋子」装了「稿费包子」。
- `salary.calculateTax()` 和 `royalty.calculateTax()`：
    
    - 我们调用的是「通用收入」的`calculateTax()`方法，但运行时，JVM 会自动识别「袋子里实际装的是工资还是稿费」，然后执行对应的子类重写方法。
    - 这就是多态：**统一调用父类方法，实际执行子类的具体实现，不用关心子类到底是谁**。
    

### 五、 为什么这就是多态？（一句话总结）

我们用同一个`Income`类型的方法`calculateTax()`，分别处理了「工资」和「稿费」两种不同的收入，得到了不同的结果，这就是多态的核心价值 ——**统一接口，不同实现**。

### 总结

1. 简化版代码聚焦多态三要素：父类`Income`、子类重写`calculateTax()`、父类引用指向子类对象。
2. 计税规则超简单，工资 5%、稿费 3%，运行结果直观易懂，无需关注复杂逻辑。
3. 多态的核心体现是：统一调用`calculateTax()`方法，自动执行对应子类的计税逻辑，不用写`if-else`判断。