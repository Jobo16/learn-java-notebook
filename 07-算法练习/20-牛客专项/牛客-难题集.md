---
title: 牛客-难题集
category: 07-算法练习
topic: 20-牛客专项
created: 2026-01-26
reviewed: 2026-02-02
tags: [java, 算法练习]
status: active
---

### 解题思路

1. **核心条件**：等式 `a * b = c` 中，`a`、`b`、`c` 拼接后的字符串必须包含 `1~9` 每个数字恰好一次，且无重复、无 0。
2. **去重与顺序**：保证 `a < b`，避免乘数交换的重复结果；最终按 `c` 升序排列，`c` 相同则按 `a` 升序排列。
3. **范围优化**：
    
    - 因为 `1~9` 共 9 个数字，所以 `a * b = c` 的数字位数组合只有两种可能：
        
        - 1 位 × 4 位 = 4 位（总位数 1+4+4=9）
        - 2 位 × 3 位 = 4 位（总位数 2+3+4=9）
        
    - 基于此缩小循环范围，避免无效计算，提升效率。
    
4. **验证方法**：将 `a`、`b`、`c` 拼接成字符串，检查是否满足「长度 9、无 0、1~9 不重复」。

### 完整 Java 代码（最简实现）

java

运行

```
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

// 存储符合条件的等式，用于后续排序
class Equation {
    int c; // 结果
    int a; // 较小乘数
    int b; // 较大乘数

    public Equation(int c, int a, int b) {
        this.c = c;
        this.a = a;
        this.b = b;
    }
}

public class Main {
    public static void main(String[] args) {
        ArrayList<Equation> resultList = new ArrayList<>();

        // 情况1：1位 × 4位 = 4位（a:1~9，b:1000~9999，c=a*b需为4位）
        for (int a = 1; a <= 9; a++) {
            for (int b = 1000; b <= 9999; b++) {
                int c = a * b;
                // 提前过滤：c必须是4位，且a < b（避免重复）
                if (c >= 1000 && c <= 9999 && a < b) {
                    if (isValid(a, b, c)) {
                        resultList.add(new Equation(c, a, b));
                    }
                }
            }
        }

        // 情况2：2位 × 3位 = 4位（a:10~99，b:100~999，c=a*b需为4位）
        for (int a = 10; a <= 99; a++) {
            for (int b = 100; b <= 999; b++) {
                int c = a * b;
                // 提前过滤：c必须是4位，且a < b（避免重复）
                if (c >= 1000 && c <= 9999 && a < b) {
                    if (isValid(a, b, c)) {
                        resultList.add(new Equation(c, a, b));
                    }
                }
            }
        }

        // 排序：先按结果c升序，再按较小乘数a升序
        Collections.sort(resultList, new Comparator<Equation>() {
            @Override
            public int compare(Equation e1, Equation e2) {
                if (e1.c != e2.c) {
                    return e1.c - e2.c;
                } else {
                    return e1.a - e2.a;
                }
            }
        });

        // 按要求格式输出
        for (Equation eq : resultList) {
            System.out.printf("%d = %d x %d%n", eq.c, eq.a, eq.b);
        }
    }

    /**
     * 验证a、b、c拼接后是否包含1~9各一次，无0无重复
     */
    private static boolean isValid(int a, int b, int c) {
        // 拼接成字符串
        String s = a + "" + b + "" + c;
        // 先判断长度是否为9（快速过滤无效情况）
        if (s.length() != 9) {
            return false;
        }
        // 检查是否包含0，或1~9是否有重复
        for (char ch = '1'; ch <= '9'; ch++) {
            int count = 0;
            for (int i = 0; i < s.length(); i++) {
                if (s.charAt(i) == ch) {
                    count++;
                } else if (s.charAt(i) == '0') { // 包含0直接无效
                    return false;
                }
            }
            // 某个数字出现次数不是1，无效
            if (count != 1) {
                return false;
            }
        }
        return true;
    }
}
```

### 代码关键部分解释

1. **`Equation` 类**：用于存储符合条件的等式的「结果、较小乘数、较大乘数」，方便后续排序和输出。
2. **两种循环场景**：针对数字位数的两种有效组合设计循环，大幅减少无效计算，比暴力枚举所有可能快很多。
3. **`isValid` 验证方法**：
    
    - 先拼接 `a`、`b`、`c` 为字符串，快速判断长度是否为 9。
    - 遍历 `1~9` 每个字符，检查其出现次数是否为 1，同时判断是否包含 `0`，满足所有条件才返回 `true`。
    
4. **排序逻辑**：使用 `Collections.sort` 自定义比较器，先按结果 `c` 升序，`c` 相同则按较小乘数 `a` 升序，满足题目输出要求。
5. **输出格式**：使用 `printf` 格式化输出，保证「等号前后空格、乘号（x）前后空格」的要求。

### 运行结果

该代码运行后，会直接输出题目示例中的所有结果，且顺序完全一致，满足题目要求。

### 总结

1. 核心是通过**数字位数组合优化循环范围**，避免无效计算，提升程序效率。
2. 验证条件的关键是检查「拼接字符串包含 1~9 各一次、无 0 无重复」。
3. 需通过自定义排序保证输出结果符合「结果小优先，结果相同则较小乘数小优先」的要求。

