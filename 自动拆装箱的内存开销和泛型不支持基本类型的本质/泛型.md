Java 泛型（Generic）是 JDK 5 引入的特性，**本质是「类型参数化」**—— 允许你定义类、接口、方法时，不指定具体的数据类型，而是用一个「占位符」（比如`T`、`E`、`K`、`V`）来表示类型，等到使用（创建对象、调用方法）时，再指定具体的类型。

简单说：泛型让你写的代码「通用」，能适配多种数据类型，同时还能保证类型安全。

举个直观对比（没有泛型 vs 有泛型）：

#### 1. 没有泛型的问题（以`List`为例）

java

运行

```
// 1. 没有泛型，List可以存储任意类型的对象
List list = new ArrayList();
list.add("张三");
list.add(18);
list.add(true);

// 2. 取出数据时，必须强制类型转换，麻烦且不安全
String name = (String) list.get(0); // 正常转换
Integer age = (Integer) list.get(1); // 正常转换
Boolean flag = (Boolean) list.get(2); // 正常转换

// 3. 容易出现类型转换异常（运行时才会报错，难以提前发现）
String error = (String) list.get(1); // 运行时抛出 ClassCastException
```

问题总结：**类型不安全（可存储任意类型）、需要手动强制类型转换、错误仅在运行时暴露**。

#### 2. 有泛型的优化

java

运行

```
// 1. 定义List时，指定泛型参数为String，表明该List只能存储String类型
List<String> list = new ArrayList<>();
list.add("张三");
// list.add(18); // 编译阶段就报错，不允许存储非String类型，提前规避错误
// list.add(true); // 编译阶段就报错

// 2. 取出数据时，无需强制类型转换，直接得到String类型
String name = list.get(0);
```

优势总结：**编译期类型安全（禁止存储非法类型）、无需手动强制类型转换、代码更简洁通用**。

### 二、 泛型的核心使用场景

泛型主要用于 3 个场景：「泛型类 / 泛型接口」、「泛型方法」，其中泛型类最常用（集合框架`List、Map、Set`都是泛型类）。

#### 1. 泛型类（Generic Class）

**定义**：在类名后添加`<类型占位符>`，占位符通常用单个大写字母表示（约定俗成，增强可读性）：

- `T`：Type（普通类型）
- `E`：Element（集合中的元素类型）
- `K`：Key（映射中的键类型）
- `V`：Value（映射中的值类型）
- `N`：Number（数值类型）

**语法格式**：

java

运行

```
// 定义泛型类：<T> 表示该类是泛型类，T是类型占位符
public class GenericClass<T> {
    // 1. 可以将泛型作为成员变量的类型（不能是基本类型，只能是引用类型）
    private T data;
    
    // 2. 可以将泛型作为构造方法的参数类型
    public GenericClass(T data) {
        this.data = data;
    }
    
    // 3. 可以将泛型作为方法的参数/返回值类型
    public T getData() {
        return data;
    }
    
    public void setData(T data) {
        this.data = data;
    }
}
```

**使用**：创建对象时，指定具体的类型（替换`T`），后续该对象的所有泛型相关操作都受该类型约束。

java

运行

```
public class GenericDemo {
    public static void main(String[] args) {
        // 1. 指定泛型为String类型，该对象只能操作String数据
        GenericClass<String> strObj = new GenericClass<>("Hello 泛型");
        String strData = strObj.getData(); // 无需强制类型转换
        System.out.println(strData); // 输出：Hello 泛型
        
        // 2. 指定泛型为Integer类型，该对象只能操作Integer数据
        GenericClass<Integer> intObj = new GenericClass<>(123);
        Integer intData = intObj.getData();
        System.out.println(intData); // 输出：123
        
        // 3. 不指定泛型（原始类型），等价于 GenericClass<Object>，会失去泛型的类型安全优势
        GenericClass obj = new GenericClass(456);
        Object data = obj.getData(); // 返回值为Object类型，需要强制转换
    }
}
```

**补充：多泛型参数**

如果需要多个类型占位符，可以用`<K, V>`、`<T1, T2>`等格式，典型示例是`Map<K, V>`：

java

运行

```
// 定义多泛型参数的类
public class GenericPair<K, V> {
    private K key;
    private V value;
    
    public GenericPair(K key, V value) {
        this.key = key;
        this.value = value;
    }
    
    // getter/setter 省略
}

// 使用
GenericPair<String, Integer> pair = new GenericPair<>("年龄", 18);
```

#### 2. 泛型接口（Generic Interface）

**定义**：和泛型类类似，在接口名后添加`<类型占位符>`。

java

运行

```
// 定义泛型接口
public interface GenericInterface<T> {
    // 泛型作为方法返回值类型
    T getValue();
    
    // 泛型作为方法参数类型
    void setValue(T value);
}
```

**实现泛型接口的两种方式**：

##### 方式 1：实现类指定具体类型（推荐，实现类不再是泛型类）

java

运行

```
// 实现接口时，指定泛型为String类型
public class GenericInterfaceImpl1 implements GenericInterface<String> {
    private String value;
    
    @Override
    public String getValue() {
        return value;
    }
    
    @Override
    public void setValue(String value) {
        this.value = value;
    }
}
```

##### 方式 2：实现类保留泛型占位符（实现类仍为泛型类，灵活度更高）

java

运行

```
// 实现接口时，保留泛型T，实现类也成为泛型类
public class GenericInterfaceImpl2<T> implements GenericInterface<T> {
    private T value;
    
    @Override
    public T getValue() {
        return value;
    }
    
    @Override
    public void setValue(T value) {
        this.value = value;
    }
}

// 使用时指定具体类型
GenericInterfaceImpl2<Integer> impl2 = new GenericInterfaceImpl2<>();
impl2.setValue(123);
```

#### 3. 泛型方法（Generic Method）

**定义**：泛型方法不是「包含泛型的方法」，而是**方法本身带有类型占位符**（在`return type`前添加`<T>`），即使所在类不是泛型类，也可以定义泛型方法。

**语法格式**：

java

运行

```
// 泛型方法：<T> 必须放在返回值类型前，表明这是一个泛型方法，T是该方法的局部类型占位符
public <T> T genericMethod(T param) {
    // 方法逻辑
    return param;
}
```

**示例**：

java

运行

```
public class GenericMethodDemo {
    // 1. 定义泛型方法（所在类不是泛型类）
    public <T> void printData(T data) {
        System.out.println("数据类型：" + data.getClass().getSimpleName() + "，数据值：" + data);
    }
    
    // 2. 泛型方法支持返回值类型为泛型
    public <T> T getDefaultValue(T defaultValue) {
        return defaultValue;
    }
    
    public static void main(String[] args) {
        GenericMethodDemo demo = new GenericMethodDemo();
        
        // 调用泛型方法，自动推断类型为String
        demo.printData("张三");
        // 调用泛型方法，自动推断类型为Integer
        demo.printData(18);
        // 调用泛型方法，自动推断类型为Boolean
        demo.printData(true);
        
        // 获取默认值，无需强制类型转换
        String strDefault = demo.getDefaultValue("默认字符串");
        Integer intDefault = demo.getDefaultValue(0);
    }
}
```

**关键提醒**：泛型方法的`<T>`是「方法局部变量」，和泛型类的`<T>`互不影响，即使同名也代表不同的类型占位符。

### 三、 泛型的核心特性（必须掌握）

#### 1. 类型擦除（Type Erasure）

这是 Java 泛型的**核心底层机制**，也是之前提到「泛型不支持基本类型」的根本原因。

**定义**：Java 泛型是「编译期泛型」，仅在**编译阶段**提供类型检查，一旦编译完成，字节码中会**擦除所有泛型信息**（将泛型占位符替换为「上限类型」，默认是`Object`），运行时 JVM 无法感知泛型的存在。

**示例验证**：

java

运行

```
public static void main(String[] args) {
    List<String> strList = new ArrayList<>();
    List<Integer> intList = new ArrayList<>();
    
    // 编译后，泛型被擦除，strList和intList的运行时类型都是ArrayList
    System.out.println(strList.getClass() == intList.getClass()); // 输出：true
}
```

**擦除规则**：

1. 无显式上限的泛型（如`<T>`）：擦除为`Object`；
2. 有显式上限的泛型（如`<T extends Number>`）：擦除为上限类型（`Number`）。

**影响**：

- 优点：保证了泛型对旧版本 Java 代码的向下兼容；
- 缺点：运行时无法获取泛型类型、泛型不支持基本类型、无法创建泛型数组（如`new T[10]`）。

#### 2. 泛型上限（Upper Bounds）

默认情况下，泛型占位符可以接受任意引用类型，但有时我们需要限制泛型的范围（比如只允许数值类型），这就需要使用「泛型上限」。

**语法**：`<T extends 上限类型>`（注意：这里的`extends`既可以继承类，也可以实现接口，统一用`extends`）。

**示例 1：泛型类指定上限**

java

运行

```
// 限制T必须是Number的子类（如Integer、Long、Double），否则编译报错
public class GenericNumber<T extends Number> {
    private T number;
    
    // 省略构造方法和getter/setter
}

// 使用
GenericNumber<Integer> intNum = new GenericNumber<>(); // 合法：Integer是Number子类
GenericNumber<Long> longNum = new GenericNumber<>(); // 合法：Long是Number子类
// GenericNumber<String> strNum = new GenericNumber<>(); // 编译报错：String不是Number子类
```

**示例 2：泛型方法指定上限**

java

运行

```
// 限制T必须是Comparable接口的实现类（支持比较大小）
public <T extends Comparable<T>> T getMax(T a, T b) {
    return a.compareTo(b) > 0 ? a : b;
}

// 使用
public static void main(String[] args) {
    GenericMethodDemo demo = new GenericMethodDemo();
    Integer maxInt = demo.getMax(10, 20); // 合法：Integer实现了Comparable
    String maxStr = demo.getMax("a", "b"); // 合法：String实现了Comparable
    // demo.getMax(new Object(), new Object()); // 编译报错：Object未实现Comparable
}
```

#### 3. 泛型下限（Lower Bounds）

泛型下限仅用于「方法参数」中，限制传入的参数类型必须是「某个类型的父类 / 本身」，语法为`<T super 下限类型>`。

最常用的场景是集合的`addAll()`方法：

java

运行

```
public static void main(String[] args) {
    List<Number> numList = new ArrayList<>();
    List<Integer> intList = new ArrayList<>();
    intList.add(1);
    intList.add(2);
    
    // 泛型下限：? super Integer 表示接受Integer及其父类（如Number、Object）类型的List
    numList.addAll(intList); // 合法：numList是List<Number>，Number是Integer的父类
    System.out.println(numList); // 输出：[1, 2]
}
```

**核心总结**：「上限用`extends`，取数据安全；下限用`super`，存数据安全」（PECS 原则：Producer Extends, Consumer Super）。

### 四、 泛型的常见坑与注意事项

1. **泛型不支持基本类型**：只能使用引用类型（如`List<Integer>`，不能写`List<int>`），原因是类型擦除后泛型会被替换为`Object`，而基本类型不继承自`Object`。
2. **不能创建泛型对象 / 泛型数组**：由于类型擦除，运行时无法确定泛型类型，因此`new T()`、`new T[10]`都是非法的。
    
    java
    
    运行
    
    ```
    public class GenericError<T> {
        // 错误：不能创建泛型对象
        // private T data = new T();
        
        // 错误：不能创建泛型数组
        // private T[] arr = new T[10];
        
        // 正确：可以创建Object数组，再强制转换（需抑制警告）
        @SuppressWarnings("unchecked")
        private T[] arr = (T[]) new Object[10];
    }
    ```
    
3. **泛型变量不能作为静态成员**：泛型类的类型占位符`T`是和「对象实例」绑定的，而静态成员是和「类」绑定的，类加载时还没有创建对象，无法确定`T`的类型。
    
    java
    
    运行
    
    ```
    public class GenericStatic<T> {
        // 错误：静态成员不能使用泛型占位符T
        // public static T data;
    }
    ```
    
4. **泛型没有多态**：`List<String>`不是`List<Object>`的子类，即使`String`是`Object`的子类，这是为了保证类型安全。
    
    java
    
    运行
    
    ```
    // 错误：泛型没有多态，无法赋值
    // List<Object> objList = new ArrayList<String>();
    ```
    
5. **包装类型比较用`equals()`**：泛型集合中存储的是包装类型，比较值时优先用`equals()`，而非`==`（避免缓存范围外的对象引用比较错误）。

### 五、 总结

1. 泛型的核心是「类型参数化」，解决了类型不安全、强制类型转换的问题，让代码更通用简洁。
2. 泛型的三大使用场景：泛型类 / 接口（`<T>`跟在类 / 接口后）、泛型方法（`<T>`跟在`public`后、返回值前）。
3. 核心特性：类型擦除（编译期有效，运行时擦除）、泛型上限（`extends`）、泛型下限（`super`）。
4. 常见坑：不支持基本类型、不能创建泛型对象 / 数组、静态成员不能使用泛型占位符、无多态。

掌握泛型的核心是理解「类型安全」和「类型擦除」，后续在使用集合框架、自定义通用工具类时，泛型会成为你不可或缺的工具。